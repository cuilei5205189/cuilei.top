{"pages":[{"title":"关于我","text":"我是谁我叫崔磊，九零后，学了五年建筑学，当了一年建筑设计师，自学编程一年，现在是一名光荣的码农。 想了解更多关于我？请看下面文章👇 你也想转行程序员？五年建筑学我学到了什么？建筑师怎么跑去写代码了？ 联系我","link":"/about/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"CSS BFC 深入浅出","text":"BFC block formatting context 用例子回答什么是 BFC父元素和子元素 See the Pen BFC 清除浮动 父包裹子 兄弟隔开 by cuilei (@cuilei5205189) on CodePen. 子元素`float`之后，父元素塌陷，不再包裹子元素。 ![][image-1] 触发**父元素的BFC**之后，父元素不在塌陷，仍然包裹子元素。 ![][image-2] *兄弟之间划清界限用 *float之后，两个元素重叠在一起。另一个元素，触发BFC之后，两个元素不再重叠。 内部子元素之间上下margin合并https://codepen.io/cuilei5205189/pen/mGpwyq?editors=1100BFC也可以阻止父元素与其第一个或最后一个子元素之间的外边距合并。也就是 里面的出不去 最前面和最后面子元素margin泄露出来。 In addition to the root element of our document (&lt;html&gt;) ,a new BFC is created in the following situations:float的值不为noneoverflow的值不为visibledisplay的值为inline-block, table-caption, table-cell中的一个position的值不为static或relativedisplay的值为flow-root elements made to float using float absolutely positioned elements (including position: fixed or position: sticky) elements with display: inline-block table cells or elements with display: table-cell, including anonymous table cells created when using thedisplay: table-* properties table captions or elements with display: table-caption block elements where overflow has a value other than visible display: flow-root elements with contain: layout, content, or strict flex items grid items multicol containers elements with column-span set to all CSS规范中对 BFC 的描述9.4.1 块格式化上下文在一个块格式化上下文中，盒在竖直方向一个接一个地放置，从包含块的顶部开始。两个兄弟盒之间的竖直距离由’margin’属性决定。同一个块格式化上下文中的相邻块级盒之间的竖直margin会合并在一个块格式化上下文中，每个盒的left外边（left outer edge）挨着包含块的left边（对于从右向左的格式化，right边挨着）。 即使存在浮动（尽管一个盒的行盒可能会因为浮动收缩），这也成立。除非该盒建立了一个新的块格式化上下文（这种情况下，该盒自身可能会因为浮动变窄） MDN 对 BFC 的描述一个块格式化上下文（block formatting context） 是Web页面的可视化CSS渲染出的一部分。它是块级盒布局出现的区域，也是浮动层元素进行交互的区域。**一个块格式化上下文由以下之一创建： 根元素或其它包含它的元素 浮动元素 (元素的 float 不是 none) 绝对定位元素 (元素具有 position 为 absolute 或 fixed) 内联块 (元素具有 display: inline-block) 表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性) 表格标题 (元素具有 display: table-caption, HTML表格标题默认属性) 具有overflow 且值不是 visible 的块元素， display: flow-root column-span: all 应当总是会创建一个新的格式化上下文，即便具有 column-span: all 的元素并不被包裹在一个多列容器中。 一个块格式化上下文包括创建它的元素内部所有内容，除了被包含于创建新的块级格式化上下文的后代元素内的元素。块格式化上下文对于定位 (参见 float) 与清除浮动 (参见 clear) 很重要。定位和清除浮动的样式规则只适用于处于同一块格式化上下文内的元素。浮动不会影响其它块格式化上下文中元素的布局，并且清除浮动只能清除同一块格式化上下文中在它前面的元素的浮动。 张鑫旭对 BFC 的描述 http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/BFC全称”Block Formatting Context”, 中文为“块级格式化上下文”。啪啦啪啦特性什么的，一言难尽，大家可以自行去查找，我这里不详述，免得乱了主次，总之，记住这么一句话：BFC元素特性表现原则就是，内部子元素再怎么翻江倒海，翻云覆雨都不会影响外部的元素。所以，避免margin穿透啊，清除浮动什么的也好理解了。 float 清除浮动用clickfix没有副作用。BFC方法会有副作用。 12345.clearfix::after { content: '' display: block clear: both} position 脱离文档流html,css 如何消除position:absolute定位脱离文档流的影响？**绝对定位会脱离文档流，父级div的宽高就没有了，怎么消除这个影响呢？像浮动有清除浮动。 个人认为这个没有css办法可以直接消除，通常的做法是：1.父元素有两个子元素，一个是定宽和绝对定位，另一个是自适应宽度，父元素靠另一个元素撑开；2.如果一定要实现题主的效果，可以用js控制，页面加载的时候判断子元素高度，用js设置父元素的高度等于或者大于子元素（看具体需要）","link":"/css-bfc/"},{"title":"cuilei-test2","text":"","link":"/cuilei-test2/"},{"title":"cuilei test3","text":"","link":"/cuilei-test3/"},{"title":"cuilei-test","text":"","link":"/cuilei-test/"},{"title":"JavaScript 数据类型转换","text":"在js中不同的类型可以相互转换，主要分成两种情况。 原始类型和对象类型转换为number、boolean、string类型。 原始类型转换为对象类型 所有类型都可以转换为 number、boolean、string转换为numberNumber()12345678910111213141516171819//BooleanNumber(true) //1Number(false) //0//StringNumber('string') //NaNNumber('100') //100Number('') //0//null undefinedNumber(null) //0Number(undefined) //NaN//数组 空数组为0，存在一个元素且为数字专数字，其他情况NaN。Number([]) //0 Number([1]) //1Number([1,2,3]) //NaNNumber({})//NaN//SymbolNumber(sym) // TypeErrorsym + 2 // TypeError +or-1234567891011121314151+'1' //\"11\"1-'1' //0+'1' //1\"a\" + + \"b\" //\"aNaN\" +\"b\"为NaNtrue + true // 24 + [1,2,3] // \"41,2,3\"{} + 0 //0 {}不是对象 是代码块obj + 0 //\"[object Object]0\"obj - 1 //NaN//那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字4 * '3' // 124 * [] // 04 * [1, 2] // NaN 转换为booleanBoolean()1234567891011121314`undefined` `null` `NaN` `0` `-0` `''` `false`转化为`false`其余都为`true`Boolean(undefined) Boolean(null) Boolean(NaN) Boolean(0) Boolean(-0) Boolean(false) Boolean('') //以上为false，其他全为true//Symbol 值也可以转为布尔值，但是不能转为数值。 let sym = Symbol();Boolean(sym) // true!sym // falseif (sym) { // ...} !or!!orif(){}!!!`操作符，和条件语句，比如if(){}`会把值转换为boolean，规律和上面提到的一样，不再赘述。 123456789//!会把一个值转换成相反boolean !!会返回值对应的boolean!flase //true!!flase //flase//if(){} ()中的值会转换成booleanif([]){ console.log(\"true I'm here\")}else { console.log(\"false I'm here\")} 转换为stringtoString()orconsole.log1234567891011121314151617181920212223242526//number1..toString() //'1'1.00000.toString() //'1'1.000001.toString() //'1.000001' //object[].toString() //\"\"🌟var obj = {}obj.toString() //\"[object Object]\"{}.toString() //error//booleantrue.toString() //\"true\"//null undefinednull.toString() //errorundefined.toString() //error//symbollet s1 = Symbol('foo');let s2 = Symbol('bar');s1 // Symbol(foo)s2 // Symbol(bar)s1.toString() // \"Symbol(foo)\"s2.toString() // \"Symbol(bar)\" String()123456789101112//objectString([]) //\"\" 🌟String([1,2]) //\"1,2\"String({}) //\"[object Object]\"`${obj1}` //\"[object Object]\"//booleanString(true) //\"true\"String(false) //\"false\"//numberString(1) //\"1\" ==对于==来说，如果对比双方的类型不一样的话，就会进行类型转换 首先会判断两者类型是否相同。相同的话就是比大小了 类型不相同的话，那么就会进行类型转换 会先判断是否在对比null和undefined，是的话就会返回true 判断两者类型是否为string和number，是的话就会将字符串转换为number 判断其中一方是否为boolean，是的话就会把boolean转为number再进行判断 判断其中一方是否为object且另一方为string、number或者symbol，是的话就会把object转为原始类型再进行判断1234567891011121314151617181920212223 //!操作符优先级高，![]转为布尔值，比较[]==false；[].toString()为\"\"，\"\"空字符串为false[] == ![] //true[] == \"\" //true[1,2] == \"1,2\" //true//两个都是数组，所以不会转换类型，数组是引用类型比较的是存储地址，这里两个数组的值虽然是一样的，但是存储地址不一样，所以不相等[] == [] //false{} ==== {} //false1 == true //true'1' == true //truenull == undefined //truevar a = {}a == \"[object Object]\" //truetrue == 1 //truefalse == 0 //falsetrue == [1] //truefalse == [0] //trueNaN == NaN //false 原始类型转换为对象类型原始类型存储的都是值，是没有函数可以调用的，比如undefined.toString()会报错。但是'cuilei'.toString()是可以使用的。 toString()来自哪里呢？显然只有对象类型才会有属性可以使用。 123456var obj = { toString: function(){ return 'hello' }}obj.toString() //'hello' obj.toString()这是我们可以完全理解的。obj中有toString这个属性，所以当然可以执行。可是'cuilei'是个单一的值，为什么也有toString属性呢？如前面所讲，JS只有七种类型，只有对象类型有属性。 所以很明显原始类型会自动转换为对象类型。 那么，所有原始类型都可以转换成对象类型吗？答案是除了nullundefined这两种类型不会自动转化成对象类型。其他的四种原始类型numberstringbooleansymbol，在调用属性时，都会转换成对象类型。 123456789//string\"cuilei\".toString()'cuilei'//booleantrue.toString() //'true'//symbolSymbol().toString() //'Symbol()'//number(1).toString() //'1'1.toString() //error JS把.当成1的小数点 为什么要转换为对象类型呢？因为这样JS可以放很多属性在对象类型中，我们可以很方便的使用。例如它们都可以调用toString()函数，把值转换成字符串。","link":"/js-data-structure-transfer/"},{"title":"JavaScript 异步","text":"JavaScript 异步，执行顺序。 ❓#BigWebQuizWhat does the console show when running this code? =====Promise.resolve().then(() =&gt; console.log(1));(async () =&gt; console.log(2))();(() =&gt; console.log(3))();setTimeout(() =&gt; console.log(4));&mdash; Chrome Developers (@ChromiumDev) 2019年6月1日","link":"/js-asynchronous/"},{"title":"JavaScript 垃圾回收机制","text":"不管什么程序语言，内存生命周期基本是一致的： 分配你所需要的内存 使用分配到的内存（读、写） 不需要时将其释放，归还 所有语言第二部分都是明确的。第一和第三部分在底层语言中是明确的，但在像JavaScript这些高级语言中，大部分都是隐含的。 JavaScript 的内存分配JavaScript 在定义变量时就完成了内存分配。 1234567891011121314151617181920var n = 123; // 给数值变量分配内存var s = \"jirengu\"; // 给字符串分配内存var o = { a: 1, b: null}; // 给对象及其包含的值分配内存// 给数组及其包含的值分配内存（就像对象一样）var a = [1, null, \"abra\"]; // 给函数（可调用的对象）分配内存function f(a){ return a + 2;} // 函数表达式也能分配一个对象someElement.addEventListener('click', function(){ someElement.style.backgroundColor = 'blue';}, false); 有些函数调用结果是分配对象内存： 12var d = new Date(); // 分配一个 Date 对象var e = document.createElement('div'); // 分配一个 DOM 元素 当内存不再需要使用时释放，大多数内存管理的问题都在这个阶段。在这里最艰难的任务是找到“所分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。 高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是无法判定的（无法通过某种算法解决）。 垃圾回收什么是垃圾？我们做个粗浅的定义，凡是之后不再将被使用的对象，都是垃圾。 垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。 在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。 引用计数垃圾收集这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。 12345678910111213141516171819202122var o = { a: { b:2 }}; // 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o// 很显然，没有一个可以被垃圾收集var o2 = o; // o2变量是第二个对“这个对象”的引用o = 1; // 现在，“这个对象”的原始引用o被o2替换了var oa = o2.a; // 引用“这个对象”的a属性// 现在，“这个对象”有两个引用了，一个是o2，一个是oao2 = \"yo\"; // 最初的对象现在已经是零引用了 // 他可以被垃圾回收了 // 然而它的属性a的对象还在被oa引用，所以还不能回收oa = null; // a属性的那个对象现在也是零引用了 // 它可以被垃圾回收了 该算法有个限制：无法处理循环引用。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。 12345678910function f(){ var o = {}; var o2 = {}; o.a = o2; // o 引用 o2 o2.a = o; // o2 引用 o return \"azerty\";}f(); 标记-清除算法 （mark-and-sweep）这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。 该算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。 此算法可以分为两个阶段，一个是标记阶段（mark），一个是清除阶段(sweep)。 标记阶段，垃圾回收器会从根对象开始遍历。每一个可以从根对象访问到的对象都会被添加一个标识，于是这个对象就被标识为可到达对象。 清除阶段，垃圾回收器会对堆内存从头到尾进行线性遍历，如果发现有对象没有被标识为可到达对象，那么就将此对象占用的内存回收，并且将原来标记为可到达对象的标识清除，以便进行下一次垃圾回收操作。 现在现代浏览器都使用了标记-清除垃圾回收算法或基于该算法的改进。 内存泄露内存中的某些对象因被引用，即使后续不再被使用也不会被回收。因某些高频率或者长时间的操作，导致该对象被不断创建，对内存的占用越来越高，导致系统剩余可用内存越来越少。 对于一般的浏览器页面，我们不必过于关心因使用闭包或者事件绑定未移除带来的内存不被释放，因为内存消耗并没有”持续变多“，当用户刷新页面或者关闭当前页面所有内存自然被释放。但在某些场景下我们需要特别关注内存泄露的问题。 场景1，高频操作。比如onscroll、onresize、setInterval、循环语句等高频场景里存在的不会被回收的对象，或者如实现动画等高频渲染的场景。 场景2，长时操作。比如使用nodejs作为后端语言搭建的网站。如果内存的使用持续增长，最终会导致服务器崩溃。 参考:MDN-内存生命周期","link":"/js-gc/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"CuiLei","slug":"CuiLei","link":"/tags/CuiLei/"},{"name":"Memory_Management","slug":"Memory-Management","link":"/tags/Memory-Management/"},{"name":"Garbage_Collection","slug":"Garbage-Collection","link":"/tags/Garbage-Collection/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Asynchronous","slug":"Asynchronous","link":"/tags/Asynchronous/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"tools","slug":"tools","link":"/tags/tools/"}],"categories":[{"name":"编程","slug":"编程","link":"/categories/编程/"},{"name":"科技","slug":"科技","link":"/categories/科技/"},{"name":"前端","slug":"编程/前端","link":"/categories/编程/前端/"},{"name":"公司","slug":"科技/公司","link":"/categories/科技/公司/"}]}